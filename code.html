#include <stdio.h>
#include <stdlib.h>

#define V 5         // Number of Vertices in Graph
#define INF 9999    // Infinity (Represents no connection)

/* =========================================================
   EXPERIMENT 25: PRIM'S ALGORITHM
   Logic: Maintain 3 arrays.
   1. parent[]: Stores the tree (Who is connected to whom?)
   2. key[]:    Stores minimum weight to reach this node.
   3. mstSet[]: Boolean. Have we included this node yet?
   ========================================================= */

// Helper: Find the vertex with minimum key value
// from the set of vertices NOT yet included in MST.
int minKey(int key[], int mstSet[]) {
    int min = INF, min_index;

    for (int v = 0; v < V; v++)
        if (mstSet[v] == 0 && key[v] < min) { // If not visited AND smaller than current min
            min = key[v];
            min_index = v;
        }

    return min_index;
}

// Function to print the constructed MST
void printPrimMST(int parent[], int graph[V][V]) {
    printf("Edge \tWeight\n");
    for (int i = 1; i < V; i++) // Start from 1 because 0 is root
        printf("%d - %d \t%d \n", parent[i], i, graph[i][parent[i]]);
}

void primMST(int graph[V][V]) {
    int parent[V];  // Array to store constructed MST
    int key[V];     // Key values used to pick minimum weight edge
    int mstSet[V];  // To represent set of vertices included in MST

    // Step 1: Initialize all keys as INFINITE and mstSet[] as false
    for (int i = 0; i < V; i++) {
        key[i] = INF;
        mstSet[i] = 0;
    }

    // Step 2: Always include first 1st vertex in MST.
    key[0] = 0;      // Make key 0 so that this vertex is picked first.
    parent[0] = -1;  // First node is always root of MST

    // Step 3: The MST will have V vertices, so loop V-1 times
    for (int count = 0; count < V - 1; count++) {
        
        // Pick the minimum key vertex from the set of vertices not yet included
        int u = minKey(key, mstSet);

        // Add the picked vertex to the MST Set
        mstSet[u] = 1;

        // Update key value and parent index of the adjacent vertices
        // of the picked vertex.
        for (int v = 0; v < V; v++) {
            // graph[u][v] is non-zero only for adjacent vertices of m
            // mstSet[v] is false for vertices not yet included in MST
            // Update the key only if graph[u][v] is smaller than key[v]
            if (graph[u][v] && mstSet[v] == 0 && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }

    printPrimMST(parent, graph);
}

/* =========================================================
   EXPERIMENT 26: KRUSKAL'S ALGORITHM
   Logic: 
   1. Store all edges in a struct list.
   2. Sort edges by weight.
   3. Union-Find logic to detect cycles.
   ========================================================= */

// Structure to represent an edge
struct Edge {
    int src, dest, weight;
};

// Structure to represent a subset for Union-Find
struct subset {
    int parent;
};

// A utility function to find the set of an element i
// (Uses path compression technique for efficiency, but simple recursion works too)
int find(struct subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
    return subsets[i].parent;
}

// A function that does union of two sets of x and y
void Union(struct subset subsets[], int x, int y) {
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);
    subsets[xroot].parent = yroot;
}

// Comparison function for sorting edges (Bubble Sort for simplicity)
void sortEdges(struct Edge edges[], int E) {
    struct Edge temp;
    for (int i = 0; i < E - 1; i++) {
        for (int j = 0; j < E - i - 1; j++) {
            if (edges[j].weight > edges[j + 1].weight) {
                temp = edges[j];
                edges[j] = edges[j + 1];
                edges[j + 1] = temp;
            }
        }
    }
}

void kruskalMST(struct Edge edges[], int E) { // E is number of edges
    struct Edge result[V];  // To store the resultant MST
    int e = 0;  // Index var, used for result[]
    int i = 0;  // Index var, used for sorted edges

    // Step 1: Sort all the edges in non-decreasing order of their weight
    sortEdges(edges, E);

    // Allocate memory for creating V subsets
    struct subset *subsets = (struct subset*) malloc(V * sizeof(struct subset));

    // Create V subsets with single elements
    for (int v = 0; v < V; ++v) {
        subsets[v].parent = v;
    }

    // Iterate through sorted edges
    while (e < V - 1 && i < E) {
        // Step 2: Pick the smallest edge. 
        struct Edge next_edge = edges[i++];

        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);

        // Step 3: If including this edge does't cause cycle (parents are different)
        if (x != y) {
            result[e++] = next_edge; // Add to result
            Union(subsets, x, y);    // Union the sets
        }
        // Else discard the next_edge
    }

    // Print the result
    printf("Edge \tWeight\n");
    for (i = 0; i < e; ++i)
        printf("%d - %d \t%d \n", result[i].src, result[i].dest, result[i].weight);
        
    free(subsets);
}

/* =========================================================
   MAIN DRIVER
   ========================================================= */
int main() {
    /* Let's create the following graph
        2    3
    (0)--(1)--(2)
     |   / \   |
    6| 8/   \5 |7
     | /     \ |
    (3)-------(4)
          9          */
          
    // Input for Prim's (Adjacency Matrix)
    int graph[V][V] = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };

    printf("--- Prim's Algorithm MST ---\n");
    primMST(graph);

    // Input for Kruskal's (Edge List)
    // We have 7 edges in the graph above
    int E = 7;
    struct Edge edges[] = {
        {0, 1, 2},
        {0, 3, 6},
        {1, 2, 3},
        {1, 3, 8},
        {1, 4, 5},
        {2, 4, 7},
        {3, 4, 9}
    };

    printf("\n--- Kruskal's Algorithm MST ---\n");
    kruskalMST(edges, E);

    return 0;
}