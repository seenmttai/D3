#include <stdio.h>
#include <stdlib.h>

#define V 5         // Number of Vertices in Graph
#define INF 9999    // Infinity (Represents no connection)

/* =========================================================
   EXPERIMENT 25: PRIM'S ALGORITHM
   Logic: Maintain 3 arrays.
   1. parent[]: Stores the tree (Who is connected to whom?)
   2. key[]:    Stores minimum weight to reach this node.
   3. mstSet[]: Boolean. Have we included this node yet?
   ========================================================= */

// Helper: Find the vertex with minimum key value
// from the set of vertices NOT yet included in MST.
int minKey(int key[], int mstSet[]) {
    int min = INF, min_index;

    for (int v = 0; v < V; v++)
        if (mstSet[v] == 0 && key[v] < min) { // If not visited AND smaller than current min
            min = key[v];
            min_index = v;
        }

    return min_index;
}

// Function to print the constructed MST
void printPrimMST(int parent[], int graph[V][V]) {
    printf("Edge \tWeight\n");
    for (int i = 1; i < V; i++) // Start from 1 because 0 is root
        printf("%d - %d \t%d \n", parent[i], i, graph[i][parent[i]]);
}

void primMST(int graph[V][V]) {
    int parent[V];  // Array to store constructed MST
    int key[V];     // Key values used to pick minimum weight edge
    int mstSet[V];  // To represent set of vertices included in MST

    // Step 1: Initialize all keys as INFINITE and mstSet[] as false
    for (int i = 0; i < V; i++) {
        key[i] = INF;
        mstSet[i] = 0;
    }

    // Step 2: Always include first 1st vertex in MST.
    key[0] = 0;      // Make key 0 so that this vertex is picked first.
    parent[0] = -1;  // First node is always root of MST

    // Step 3: The MST will have V vertices, so loop V-1 times
    for (int count = 0; count < V - 1; count++) {
        
        // Pick the minimum key vertex from the set of vertices not yet included
        int u = minKey(key, mstSet);

        // Add the picked vertex to the MST Set
        mstSet[u] = 1;

        // Update key value and parent index of the adjacent vertices
        // of the picked vertex.
        for (int v = 0; v < V; v++) {
            // graph[u][v] is non-zero only for adjacent vertices of m
            // mstSet[v] is false for vertices not yet included in MST
            // Update the key only if graph[u][v] is smaller than key[v]
            if (graph[u][v] && mstSet[v] == 0 && graph[u][v] < key[v]) {
                parent[v] = u;
                key[v] = graph[u][v];
            }
        }
    }

    printPrimMST(parent, graph);
}

/* =========================================================
   EXPERIMENT 26: KRUSKAL'S ALGORITHM
   Logic: 
   1. Store all edges in a struct list.
   2. Sort edges by weight.
   3. Union-Find logic to detect cycles.
   ========================================================= */

// Structure to represent an edge
struct Edge {
    int src, dest, weight;
};

// Structure to represent a subset for Union-Find
struct subset {
    int parent;
};

// A utility function to find the set of an element i
// (Uses path compression technique for efficiency, but simple recursion works too)
int find(struct subset subsets[], int i) {
    if (subsets[i].parent != i)
        subsets[i].parent = find(subsets, subsets[i].parent);
    return subsets[i].parent;
}

// A function that does union of two sets of x and y
void Union(struct subset subsets[], int x, int y) {
    int xroot = find(subsets, x);
    int yroot = find(subsets, y);
    subsets[xroot].parent = yroot;
}

// Comparison function for sorting edges (Bubble Sort for simplicity)
void sortEdges(struct Edge edges[], int E) {
    struct Edge temp;
    for (int i = 0; i < E - 1; i++) {
        for (int j = 0; j < E - i - 1; j++) {
            if (edges[j].weight > edges[j + 1].weight) {
                temp = edges[j];
                edges[j] = edges[j + 1];
                edges[j + 1] = temp;
            }
        }
    }
}

void kruskalMST(struct Edge edges[], int E) { // E is number of edges
    struct Edge result[V];  // To store the resultant MST
    int e = 0;  // Index var, used for result[]
    int i = 0;  // Index var, used for sorted edges

    // Step 1: Sort all the edges in non-decreasing order of their weight
    sortEdges(edges, E);

    // Allocate memory for creating V subsets
    struct subset *subsets = (struct subset*) malloc(V * sizeof(struct subset));

    // Create V subsets with single elements
    for (int v = 0; v < V; ++v) {
        subsets[v].parent = v;
    }

    // Iterate through sorted edges
    while (e < V - 1 && i < E) {
        // Step 2: Pick the smallest edge. 
        struct Edge next_edge = edges[i++];

        int x = find(subsets, next_edge.src);
        int y = find(subsets, next_edge.dest);

        // Step 3: If including this edge does't cause cycle (parents are different)
        if (x != y) {
            result[e++] = next_edge; // Add to result
            Union(subsets, x, y);    // Union the sets
        }
        // Else discard the next_edge
    }

    // Print the result
    printf("Edge \tWeight\n");
    for (i = 0; i < e; ++i)
        printf("%d - %d \t%d \n", result[i].src, result[i].dest, result[i].weight);
        
    free(subsets);
}

/* =========================================================
   MAIN DRIVER
   ========================================================= */
int main() {
    /* Let's create the following graph
        2    3
    (0)--(1)--(2)
     |   / \   |
    6| 8/   \5 |7
     | /     \ |
    (3)-------(4)
          9          */
          
    // Input for Prim's (Adjacency Matrix)
    int graph[V][V] = {
        {0, 2, 0, 6, 0},
        {2, 0, 3, 8, 5},
        {0, 3, 0, 0, 7},
        {6, 8, 0, 0, 9},
        {0, 5, 7, 9, 0}
    };

    printf("--- Prim's Algorithm MST ---\n");
    primMST(graph);

    // Input for Kruskal's (Edge List)
    // We have 7 edges in the graph above
    int E = 7;
    struct Edge edges[] = {
        {0, 1, 2},
        {0, 3, 6},
        {1, 2, 3},
        {1, 3, 8},
        {1, 4, 5},
        {2, 4, 7},
        {3, 4, 9}
    };

    printf("\n--- Kruskal's Algorithm MST ---\n");
    kruskalMST(edges, E);

    return 0;
}


Here is the cheat sheet for Time Complexity, Space Complexity, and Real-World Applications for all 26 experiments.

**Note on Space Complexity:** For Sorting algorithms, I have listed **Auxiliary Space** (extra space needed besides the input array). For Data Structures (Stacks, Queues, Lists), the space is always **O(n)** because you need to store `n` elements.

---

### **Section 1: Searching**

| Exp | Name | Time Complexity (Worst) | Space Complexity | Why use it? (Application) |
| :--- | :--- | :--- | :--- | :--- |
| **1** | **Linear Search** | $O(n)$ | $O(1)$ | Used when data is **unsorted** or the list is very small (e.g., finding a specific shirt in a pile). |
| **2** | **Binary Search** | $O(\log n)$ | $O(1)$ | Used for **sorted** data. Used in dictionaries, library catalogs, and database indexing. |

---

### **Section 2: Sorting**

| Exp | Name | Time Complexity (Avg/Worst) | Space (Aux) | Why use it? (Application) |
| :--- | :--- | :--- | :--- | :--- |
| **3** | **Bubble Sort** | $O(n^2)$ | $O(1)$ | Rarely used in production. Good for teaching and detecting if a list is **already sorted** (Best case $O(n)$). |
| **4** | **Selection Sort** | $O(n^2)$ | $O(1)$ | Good when **write operations** are expensive (e.g., Flash memory), as it makes the fewest swaps. |
| **5** | **Insertion Sort** | $O(n^2)$ | $O(1)$ | Excellent for **small arrays** or data that is already **mostly sorted**. Used inside hybrid algorithms (like Timsort in Python). |
| **6** | **Quick Sort** | $O(n \log n)$ / $O(n^2)$ | $O(\log n)$ | The **fastest** general-purpose sort for arrays in RAM. Used in C++ `std::sort`. |
| **7** | **Merge Sort** | $O(n \log n)$ | $O(n)$ | Stable sort. Best for **Linked Lists** and sorting huge files that don't fit in RAM (External Sorting). |
| **23** | **Heap Sort** | $O(n \log n)$ | $O(1)$ | Good for embedded systems with **low memory** (since it's $O(1)$ space). Used in Priority Queues. |

---

### **Section 3: Arrays**

| Exp | Name | Time Complexity | Space | Why use it? (Application) |
| :--- | :--- | :--- | :--- | :--- |
| **8** | **Insert Element** | $O(n)$ | $O(1)$ | Adding an item to a list (requires shifting elements to make space). |
| **9** | **Delete Element** | $O(n)$ | $O(1)$ | Removing an item (requires shifting elements to fill the gap). |
| **10** | **Merge Arrays** | $O(n + m)$ | $O(n + m)$ | combining two sorted lists into one. This is the core logic step inside **Merge Sort**. |

---

### **Section 4: Stacks & Queues**

| Exp | Name | Time Complexity | Space | Why use it? (Application) |
| :--- | :--- | :--- | :--- | :--- |
| **11** | **Stack (Array)** | Push/Pop: $O(1)$ | $O(n)$ | **Undo/Redo** buttons (Ctrl+Z), Browser Back button, Function calls (Recursion). |
| **12** | **Queue (Array)** | Enq/Deq: $O(1)$ | $O(n)$ | **Printer Spooling** (First doc sent is first printed), CPU Task scheduling. |
| **13** | **Circular Queue** | Enq/Deq: $O(1)$ | $O(n)$ | **Streaming Buffers** (Netflix loading bar), Traffic light controllers (cycles repeatedly). |
| **15** | **Stack (Linked List)**| Push/Pop: $O(1)$ | $O(n)$ | Same as Stack (Array), but the size is **dynamic** (doesn't get full). |
| **16** | **Queue (Linked List)**| Enq/Deq: $O(1)$ | $O(n)$ | Same as Queue (Array), but dynamic size. |

---

### **Section 5: Linked Lists**

| Exp | Name | Time Complexity | Space | Why use it? (Application) |
| :--- | :--- | :--- | :--- | :--- |
| **14** | **Linear Linked List** | Search: $O(n)$ <br> Insert: $O(1)$* | $O(n)$ | Dynamic memory allocation. Used when you don't know how much data you will have. |
| **17** | **Count Items** | $O(n)$ | $O(1)$ | Data analysis (frequency count). |
| **18** | **Update Items** | $O(n)$ | $O(1)$ | Batch processing (e.g., increasing everyone's salary by 10%). |
| **19** | **Doubly Linked List** | Search: $O(n)$ <br> Delete: $O(1)$* | $O(n)$ | **Music Players** (Next/Previous song), Browser History (Forward/Back navigation). |

*\*Note: Insert/Delete is $O(1)$ only if you already have the pointer to that location. Finding the location still takes $O(n)$.*

---

### **Section 6: Trees**

| Exp | Name | Time Complexity | Space | Why use it? (Application) |
| :--- | :--- | :--- | :--- | :--- |
| **20** | **BST Creation** | Search/Insert: $O(\log n)$ <br> (Worst $O(n)$) | $O(n)$ | **Databases**, File Systems, Autocomplete features. |
| **21** | **Delete Node** | $O(\log n)$ | $O(n)$ | Removing files or records from a database efficiently. |
| **22** | **Tree Traversals** | $O(n)$ | $O(n)$ | **Compilers** (parsing code syntax), Mathematical expression evaluation. |

---

### **Section 7: Graphs**

| Exp | Name | Time Complexity | Space | Why use it? (Application) |
| :--- | :--- | :--- | :--- | :--- |
| **24** | **BFS / DFS** | $O(V + E)$ | $O(V)$ | **BFS:** Social Networks (finding "Friends of Friends"), GPS (Shortest path). <br> **DFS:** Solving Mazes, Sudoku. |
| **25** | **Prim's Algorithm** | $O(E \log V)$ | $O(V)$ | **Network Design:** Connecting all computers in a LAN with the least amount of cable. |
| **26** | **Kruskal's Algorithm**| $O(E \log E)$ | $O(V)$ | **Road Networks:** Connecting cities with minimum cost/road length. |

*Legend: $n$ = number of elements, $V$ = Vertices (nodes), $E$ = Edges (connections).*